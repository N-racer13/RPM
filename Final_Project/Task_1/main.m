%% This script is used to test PRM and RRT algorithm for 4-link manipulator
clc;clear;close
% Load configuration space generated by pointCloudGenerate
load('multiple_jointstates.mat')

%% Parameters predefine
length = 25; % robot link length
linkLen = ones(4,1)*length; % four robot segment
linkAng = {(0:1:2*pi), (0:1:2*pi), (0:1:2*pi), (0:1:2*pi)}; % joints limitation
colors = [92, 75, 81; 140, 190, 178; 242, 235, 191; 243, 181, 98; 240, 96, 96]./255;

% World size
L_world = [-100, 100];

% Initial and goal point
p_init = [20; 20];
p_goal = [-40; 0];

% Multiple obstacles
N_obs = 6; % number of obstacles
B = {};

B{1} = [25 45 50 30 20; 30 30 45 50 45];
B{2} = [-30 30 60 -60; 80 80 100 100];
B{3} = [-70 -25 -50; 30 30 60];
B{4} = [30 45 90; 0 -60 10];
B{5} = [-35 -50 -50 -40 10; -20 -40 -70 -90 -50];

%% Create collision map for constructing configuration space
% Generate configuration space, type 0 to skip this operation if using
% initial environment setup
mapIndex = input(['Need to regenerate configuration space?\n', ...
    'This operation is typically required when the initial setup, ', ...
    'such as the shapes and positions of obstacles, changes.\n',...
    'However, it is not necessary if only the goal or start points are altered.\n', ...
    '(0 for skipping, 1 for continuing): ']);
if mapIndex
    warning('This operation is usually time-consuming.')
    warning('Do not attempt to resize figure window(eg. full screen the window)')
    [collisionMap, jointState, xe, ye] = pointCloudGenerate(linkLen, linkAng, colors, L_world, B, p_init, p_goal);
end

algorithmIndex = input('Which algorithm will be used?(0 for PRM, 1 for RRT):');

%% PRM
if ~algorithmIndex
    disp('Running PRM algorithm...')
    warning('Do not attempt to resize the figure window(eg. full screen the window)')
    N = 1000;
    K = 15;
    pointSpace = [xe; ye];
    xPRM = [];
    yPRM = [];

    % Apply PRM algorithm
    [PRMPath, V, G] = PRM(N, K, linkLen, p_init, p_goal, pointSpace, jointState, B);

    xtemp = [];
    ytemp = [];
    for i = 1:size(V, 2) 
        [xtemp(end+1), ytemp(end+1)] = FK(linkLen, V(1, i), V(2, i), V(3, i), V(4, i));
    end

    % Plot PRM trajectory
    interval = 10;
    PRMInterPath = zeros(4, (interval+1)*(size(PRMPath,2)-1)+1);
    PRMInterPath(:, 1:interval+1:end) = PRMPath; % add more points between two joint states
    for j = 1:size(PRMPath, 2)-1
        for i = 1:interval 
            PRMCurrentState = (PRMPath(:, j+1) - PRMPath(:, j))*i/interval + PRMPath(:, j);
            PRMInterPath(:, (interval+1)*(j-1)+i+1) = PRMCurrentState;
        end
    end

    % Create PRM demonstration animation
    PRMVideo = VideoWriter('PRM Demonstration.mp4', 'MPEG-4');
    PRMVideo.Quality = 50; % parameter for the video
    PRMVideo.FrameRate = 20;
    open(PRMVideo);

    figure(2)
    hold on

    for ix = 1:size(PRMInterPath,2)
        hold on
        axis([-100, 100, -100, 100]);
        xlabel('X');
        ylabel('Y');
        % Scatter sample point
        scatter(xtemp, ytemp,'marker', '.', 'MarkerEdgeColor', [92, 78, 70]./255)
        % Plot obstacles and points
        for i = 1:size(B,2)
          plot(polyshape(B{i}(1,:),B{i}(2,:)), 'FaceColor', colors(i, :));
        end
        plot(p_init(1),p_init(2),'b.','MarkerSize',25)
        plot(p_goal(1),p_goal(2),'r.','MarkerSize',25)
        text(p_init(1)-20, p_init(2)+10, 'Start Point', 'color', 'b', 'FontWeight', 'bold');
        text(p_goal(1)-20,p_goal(2)+10,'Goal Point','color', 'r', 'FontWeight', 'bold');

        [xPRM(end+1), yPRM(end+1)] = FK(linkLen, PRMInterPath(1, ix), PRMInterPath(2, ix), PRMInterPath(3, ix), PRMInterPath(4, ix));
        drawRobot(linkLen, PRMInterPath(1, ix), PRMInterPath(2, ix), PRMInterPath(3, ix), PRMInterPath(4, ix));
        plot(xPRM, yPRM, 'r-', 'LineWidth', 2)
        plot(xPRM(end), yPRM(end), 'ro')

        drawnow;
        frame = getframe(gcf); % gcf gets the current figure handle
        writeVideo(PRMVideo, frame);
        clf

    end

    close(PRMVideo)
    close
end

%% RRT
if algorithmIndex
    disp('Running RRT algorithm...')
    warning('Do not attempt to resize the figure window(eg. full screen the window)')
    N = 20000;
    delta_q = 0.05;
    tolerance = 1;
    bias = 0.05; % degree of deviation toward the target point; higher 
                % values increase the likelihood of sampled points moving towards the target
    pointSpace = [xe; ye];
    xRRT = [];
    yRRT = [];

    % Apply RRT algorithm
    [RRTPath, V, E] = RRT(N, delta_q, tolerance, bias, linkLen, p_init, p_goal, pointSpace, jointState, B);

    xtemp = [];
    ytemp = [];
    for i = 1:size(V, 2) 
        [xtemp(end+1), ytemp(end+1)] = FK(linkLen, V(1, i), V(2, i), V(3, i), V(4, i));
    end

    % Plot RRT trajectory

    % Create PRM demonstration animation
    RRTVideo = VideoWriter('RRT Demonstration.mp4', 'MPEG-4');
    RRTVideo.Quality = 50; % parameter for the video
    RRTVideo.FrameRate = 20;
    open(RRTVideo);

    figure(2)
    hold on

    for ix = 1:size(RRTPath,2)
        hold on
        axis([-100, 100, -100, 100]);
        xlabel('X');
        ylabel('Y');
        % Scatter sample point
        scatter(xtemp, ytemp,'marker', '.', 'MarkerEdgeColor', [92, 78, 70]./255)
        % Plot obstacles and points
        for i = 1:size(B,2)
          plot(polyshape(B{i}(1,:),B{i}(2,:)), 'FaceColor', colors(i, :));
        end
        plot(p_init(1),p_init(2),'b.','MarkerSize',25)
        plot(p_goal(1),p_goal(2),'r.','MarkerSize',25)
        text(p_init(1)-20, p_init(2)+10, 'Start Point', 'color', 'b', 'FontWeight', 'bold');
        text(p_goal(1)-20,p_goal(2)+10,'Goal Point','color', 'r', 'FontWeight', 'bold');

        [xRRT(end+1), yRRT(end+1)] = FK(linkLen, RRTPath(1, ix), RRTPath(2, ix), RRTPath(3, ix), RRTPath(4, ix));
        drawRobot(linkLen, RRTPath(1, ix), RRTPath(2, ix), RRTPath(3, ix), RRTPath(4, ix));
        plot(xRRT, yRRT, 'r-', 'LineWidth', 2)
        plot(xRRT(end), yRRT(end), 'ro')

        drawnow;
        frame = getframe(gcf); % gcf gets the current figure handle
        writeVideo(RRTVideo, frame);
        clf

    end

    close(RRTVideo)
    close
    
end
